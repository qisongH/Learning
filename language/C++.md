# 目录

* [new和malloc的区别](#new和malloc的区别)
* * [自由存储区和堆的区别](#自由存储区和堆的区别)
  * [内存分配](#内存分配)
* [memcpy()函数](#memcpy()函数)
* [数组存放位置](#数组存放位置)
* [static关键字](#static关键字)
* [const关键字](#const关键字)
* * [define关键字](#define关键字)
* [volatile关键字](#volatile关键字)





## new和malloc的区别

1、new、delete是C++中独有的**操作符**，而malloc和free是C/C++中的**标准库函数**。

2、使用new创建对象再分配内存的同时会**自动调用构造函数**，同时也可以完成对对象的**初始化**，同理要记得delete也能自动调用析构函数，而malloc只是单纯的为变量分配内存，free也只是释放变量的内存。

3、new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而malloc返回的是**void**类型，需要将其强制转化为实际类型的指针，并且需要指定好要申请内存的大小。

4、C++允许**重载**new/delete操作符，而malloc和free是一个函数，并不能重载。

5、new内存分配失败时，会抛出bac_alloc**异常**，malloc分配内存失败时**返回NULL**。

6、new从**自由存储区**上为对象动态分配空间，而malloc函数从**堆**上动态分配内存。

### 自由存储区和堆的区别

>1、自由存储区是C++中通过new和delete动态分配和释放对象的**抽象概念**，而**堆（heap）**是C语言和操作系统的术语，是操作系统维护的一块动态分配的内存。
>
>2、基本上所有的C++编译器默认使用堆来实现自由存储，缺省的new和delete其实是按照malloc和free的方式来实现的，此时可以认为 *自由存储区等价于堆* ；如果通过重载运算符的方式，改用其他内存来实现自由存储，比如全局变量做的对象池，此时自由存储区就区别于堆了。
>
>3、堆和自由存储区是有区别的，并非等价。
>
>参考：https://www.cnblogs.com/QG-whz/p/5060894.html

### 内存分配

Linux维护一个**break指针**，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间是映射好的，可以供进程访问；而从break指针往上，如果访问这段空间则程序报错。用malloc进行内存分配就是从break往上进行。

![](https://i.loli.net/2020/11/30/R7huLjsUAM4TBQE.png)

![](https://i.loli.net/2020/11/30/kflZXRSpA4oPK2z.png)

* malloc的整体实现方案

> malloc函数实质是**有一个可用的内存块（连接成了一个长长的列表-空闲链表）**。调用malloc()函数时，沿着空闲链表寻找一个足以满足用户请求所需要的**内存块**，将该内存块一分为二，一块分配给用户，剩下的那块返回到空闲链表。当调用free函数时，将用户释放的内存块重新连接到空闲链表上。最后，**空闲链表会被切成很多的小内存片段**。如果用户还要申请一个大的内存块，空闲链表上可能没有可以满足用户要求的片段了。此时，malloc()函数**请求延时**，开始在空闲链表上检查各内存片段，**对它们进行内存整理，将相邻的小空闲块合并成较大的内存块**。

* 内存分配的方式

1、**从静态存储区域分配**：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。比如 *全局变量，static变量*。

2、**在栈上分配**：函数内的局部变量都可以在栈上分配，函数执行结束时这些存储单元也被自动释放。*栈内存分配运算内置于指令集中，效率很高，但是分配的内存容量有限*。

3、**堆上分配（动态内存分配）**：程序员用malloc或new申请任意多少的内存，用free和delete进行释放。动态内存的生存期由程序员决定，使用灵活，但是容易出现 *内存泄露*，**频繁地分配和释放不同大小的堆空间将会产生堆内碎块**。

## memcpy()函数

* 注意事项：需要考虑地址重叠的情况

> 比如 int arr = {1,2,3,4,5}，考虑两种情况
>
> 1、源地址 arr[2]，目标地址 arr[0]，自前向后拷贝3个元素后为 {3,4,5,4,5}
>
> 2、源地址 arr[0]，目标地址 arr[2]，**自后向前**拷贝3个元素后为 {1,2,1,2,3}

```c++
void *Memcpy(void *dst, const void *src, size_t size)
{
    char *psrc;		// 源地址
    char *pdst;		// 目标地址
    
    if (NULL == dst || NULL == src)
    {
		return NULL;
    }
    
    if ((src < dst) && (char *)src + size > (char *) dst)	// 源地址再前，目标地址在后，对应第二种情况，需要自后向前拷贝
    {
        psrc = (char *)src + size - 1;	// 一个字节一个字节拷贝，所以转换为 char*
        pdst = (char *)dst + size - 1;
        while (size --)
        {
            *pdst -- = *psrc --;
        }
    }
    else	// 对应第一种情况，直接逐个拷贝 
    {
		psrc = (char *)src;
        pdst = (char *)dst;
        while (size --)
        {
            *pdst ++ = *psrc ++;
        }
    }
    return dst;
}
```

## 数组存放位置

1、*固定数组* 在**函数体内**分配（不带static）是在**栈**中；

2、*固定数组* 是**全局变量或带static修饰的局部数组**都是在**静态存储区**中；

3、*固定数组* 在**类**中分配是在**堆**中；

4、*动态数组*（通过malloc或者new）不管在函数体中、类中、全局变量，都是在**堆**中。

## static关键字

* 在C语言中，static作用：**“改变生命周期” 或者 “改变作用域”**。有以下特性：

1）**static局部变量**：局部变量为动态存储，*即指令执行到定义处才分配内存*，将一个变量声明为函数的局部变量，使其变为**静态存储方式(静态数据区)**，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。

2）**static全局变量**：全局变量即定义{}外面，其本身就是静态变量，编译时就分配内存，**这只会改变其连接方式，使其只在本文件内部有效，而其他文件不可连接或引用该变量**。

3）**static函数**：**对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的**。这样的函数又叫作*静态函数*。使用静态函数的好处是，**不用担心与其他文件的同名函数产生干扰**，另外也是对函数本身的一种**保护机制**。如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可。

* 到了C++的时候，static多了几个其他的作用：

4）**static类成员变量**：表示这个成员为**全类所共有**，对类的**所有对象只有一份拷贝**，可以借助类名直接访问。

5）**static类成员函数**：表示这个函数为**全类所共有**，而且**只能访问静态成员变量**，因为*这个函数不接收this指针*。

## const关键字

Const就是常量修饰符，const变量应该在声明的时候就进行初始化，*如果在声明常量的时候没有提供值，则该常量的值是不确定的，且无法修改*。

* const修饰主要用来修饰变量、函数形参和类成员函数：

1）**const常量**：定义时就初始化，以后不能更改。

2）**const形参**：func(const int a){}; *该形参在函数里不能改变*

3）**const修饰类成员函数**：该函数对成员变量只能进行**只读操作，就是const类成员函数是不能修改成员变量的数值的**。

### define关键字

1）用#define MAX 255定义的常量是**没有类型**的（**不进行类型安全检查**，可能会产生意想不到的错误），所给出的是一个**立即数**，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在**预处理**的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

用const int MAX = 255;定义的常量**有类型**（**编译时会进行类型检查**），存放在内存的**静态区域**中，在**编译时**确定其值。在程序运行过程中const变量只有**一个拷贝**，而 #define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的**内存**要比const变量的大得多；

2）用define定义的常量是*不可以用指针变量去指向的*，用const定义的常量是可以用指针去指向该常量的地址的；

3）用define可以定义一些简单的函数（**宏替换只作替换，不做计算，不做表达式求解**），const是不可以定义函数的。

4）**宏定义的作用范围仅限于当前文件**。 而默认状态下，const对象只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。 如果想在多个文件之间共享const对象，必须在变量定义之前添加*extern关键字*（在声明和定义时都要加）。

## volatile关键字

本意是 *易变的* ，因为**访问寄存器要比访问内存单元快的多**，所以编译器一般会做**减少存取内存单元的优化**，因为有可能**读脏数据**。当使用volatile声明变量值的时候，编译器对访问该变量的代码**不再进行优化**，系统总是重新从它所在的**内存单元中读取数据**。

> **作用**：影响编译器编译的结果，用volatile声明的变量表示 *该变量随时可能改变*，因为与该变量有关的运算 *不要进行编译优化*，以免出错。

* 案例

（1）中断服务程序中修改的变量

```C++
int i = 0;		// volatile int i = 0;
int main(void)
{
	...
	while (1)
	{
		if (i)
			dosomething();
	}
}

// 中断服务函数
void ISR_i(void)
{
	i = 1;
}
```

编译器判断在 main 函数内没有对 i 进行修改，因此可能**只执行一次从 i 到某寄存器的读操作**，然后每次 if 判断都只使用**这个寄存器里面的 i 副本**，导致 **dosomething()永远无法执行**。如果加上 volatile 关键字修饰，可以保证编译器不对该变量的读写操作进行优化。 

（2）**多任务（多线程）**环境下各任务间**共享的标志**应该加 volatile；

（3）存储器映射的**硬件寄存器**通常也要加，因为每次对它的读写都可能不一样。

> 假设要发送1字节数据到串口设备，此设备的发送寄存器为 0xFFF80000

```C++
// volatile int *TxBuff = (volatile unsigned int *)(0xFFF80000);
int *TxBuff = (unsigned int *)(0xFFF80000);	// IO端口
int SendByte(void)	// 优化前
{
    int i;
    for (i = 0; i < 8; ++ i)
    {
        *TxBuff = i % 2;
    }
}
// 经过编译器优化后，可能认为前面循环半天都是废话，对最后的结果毫无影响，所以优化后的代码相当于：
int SendByte(void)	// 优化后
{
	*TxBuff = 1;
}
```



